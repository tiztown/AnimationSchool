Классы 
=======

  *Python получил свое название не от змеи питона, а в честь комедийного шоу Monty Python and the holy grail, который вышел в Британском кино-прокате в 1975 году и фанатом которого являлется Guido van Rossum - создатель языка программирования Python и который на данный момент работает в компании Dropbox (до этого работал в Google)*

Во многих языках программирования есть такая вещь как Классы. Если помните, я говорил, что любую программу следует "дробить" на более мелкие компоненты - функции. Дробление на функции это очень важный момент в программировании - ведь оно позволяет преобразовать программу в более организованный вид. Одни и те же функции можно использовать много раз, с разными аргументами - получая различные результаты.  И функции  - это прекрасно ... пока речь идет о небольших программах. Однако, когда древние программисты (еще те, что при царях жили) столкнулись с такой проблемой, как организация сложных программ, состоящих из кучи файлов и огромного числа строк кода - они осознали всю примитивность функций, и решили придумать новый способ организации кода, который бы позволил держать в голове под контролем весь проект. 

Они сидели долго, спорили о жизни, обществе, политике, крестьянах, драконах, мироздании и эволюции, пока не начали драться и называть друг друга холопами, собаками и крысами и говорили (скорее орали) друг другу, мол, не лезть туда, где ничего не смыслишь. В конце концов, придумали они для организации функций - **Классы**, каждый из который отвечал бы за определенный набор действий, и чтобы эти классы обменивались своими функциями между собой, не могли навредить друг другу, и в программе царили бы гармония и процветание. Назвали они это нововведение - Объектно Ориентированное Программирование (или ООП), описали как должны работать Классы и выпустили классы в массы, ознаменовав этим событием новую эру программирования. 

В Python заложен весь необходимый функционал, чтобы мы могли создавать и полностью контролировать классы. В основном все программисты работают именно с классами а не с отдельными функциями, т.к. их гибкость позволяет создавать очень сложные взаимосвязи между программами легко и непринужденно. Фреймворк Qt, который используется для создания интерфейсов любой сложности, так же работает с помощью классов. 


.. figure:: res/classes.jpg
    :align: left
    :alt: alternate text
    :figclass: align-center



Введение
--------

Чтобы проще понять, что такое классы - рассмотрим простой пример.

Представьте город, в котором живут одни повара да их помощники. Они добывают еду, готовят ее, готовят соусы и приправы, одним словом, знают все что касается еды и количество жителей этого города неограничено. В другом городе, рядом, живут одни доктора, которые знаю все про болезни и методы лечения от этих болезней. Третий город - войны и солдаты, знают все премудрости ведения сражений. Четвертый город - инженеры. И так далее. 

И теперь, представьте, что вам доверили создать город, который занимался бы созданием автомобилей. Любой город, безусловно, не может существовать без врачей, учителей, инженеров, политиков - поэтому мы с каждого вышеописанного города берем себе по человеку, который несет в себе все знания своего города. Одного учителя, одного инженера, повара, но мы берем людей не со всех городов, а лишь с тех, чьи знания и опыт позволят нам построить наш автомобилестроительный город. Нам не нужны специалисты по летучим мышам или по выращиванию кофе. Они не принесут никакой пользы. Поскольку автомобилестроением никто из выше перечисленных городов не занимается - мы должны дать им инструкции, как делать колеса, как собирать трансмиссию, двигатель и т.д. И вот у нас уже есть свой город где живут специалисты по автомобилям, которые несут в себе все знания предыдущих городов из которых они пришли, а так же знания нашего города. Теперь, если какому-то новому городу понадобится построить автомобиль, мы выдадим ему своего специалиста. 

А теперь змените города на классы, то что жители этих городов обучены делать - на функции этих классов, а сами жители - это объекты классов. 

Классы это просто еще один вид организации кода, когда функции объединяются в группы с каким-то названием. Они позволяют структурировать код так, чтобы нам было интуитивно понятно и приятно с ним работать.

Практические заметки
--------------------

Рассмотрим пример класса Повара, который, как описано выше, умеет делать все что связано с едой и ее готовкой.

.. code-block:: python

    class Cook():

        def fry(self, food = None):
            print (food + " has been fried")

        def boil(self, food = None):
            print (food + " has been boiled")

        def grill(self, food = None):
            print (food + "has been grilled")

    cook_1 = Cook()
    cook_2 = Cook()

В данном примере, Cook - это класс повара. Но мы не можем использовать этот класс по себе (можем конечно, но об этом дальше). Мы должны взять человека ( в нашем случае переменную), и сделать его поваром, выполнив cook_1 = Cook(). Мы можем сделать сколько угодно переменных-поваров, однако иногда в этом нет смысла и нам достаточно одного повара. 

Теперь, наш повар умеет делать все что прописано в классе Cook. Чтобы повар пожарил еду, мы выполним следующее.

.. code-block:: python

    cook_1.boil(food = "chicken") #  output: chicken has been boiled
    cook_1.grill(food = "fish") # fish has been grilled

Внутри класса, мы используем ключевое слово **self**, которое дает Питону понять, что эта функция принадлежит именно этому классу а не взята извне.  Так же мы в классе можем объявлять переменные,  которые будут начинаться с self:

.. code-block:: python

    self.myVar = 15
    print self.myVar

То же самое и с функциями, как только мы создали функцию внутри класса и в качестве первого аргумента указали self - эта функция автоматически становится видной для других функций класса. Вызывать такую функцию внутри класса нужно через self (как и переменную)

.. code-block:: python

    self.grill(food = "some food")

Если мы создадим несколько объектов класса (cook_1, cook_2) - в чем тогда смысл если они делают одно и то же?  А вот и не одно и то же, каждый объект класса может иметь уникальные свойства (повара бывают плохие, хорошие, старые, молодые, больные - и все это влияет на качество приготовления еды и на результат работы класса). В классе существует уникальная функция, которая запускается каждый раз, когда мы создаем новый объект. Называется она initialize и пишется **def __init__(self)**. В нее мы можем передать аргументы, и использовать их в дальнейшем в классе, например:

.. code-block:: python

    class Cook():

        def __init__(self, cookName = None, cookAge = None, cookLevel = 0):

            self.name = cookName
            self.age = cookAge
            self.level = cookLevel

        def fry(self, food = None):
            print (food + " has been fried")

        def boil(self, food = None):
            print (food + " has been boiled")

        def grill(self, food = None):
            print (food + "has been grilled")

    cook_1 = Cook(cookName = "Bob", cookAge = "45", cookLevel = 80)
    cook_2 = Cook(cookName = "Bill", cookAge = "25", cookLevel = 45)

    print cook_1.name   #Bob
    print cook_1.age    #45
    print cook_1.level  #80


В примере выше мы создали повара, и дали ему уникальное имя, возраст и его уровень готовки. Всю эту информацию мы можем использовать в различных функциях класса, причем чтобы получить доступ к переменной, или сохранить в нее результат, больше не нужны никакие дополнительные действия как глобальные переменные - мы просто пишем имя переменной где нужно, и она будет доступной.

.. code-block:: python

    def fry(self, food  = None):
        self.level = self.level + 1  #increase cook level
        print (food + " has been fried")  

Теперь для всех функций класса, где бы мы снова не обратились к переменной self.level - она будет уже на одну единичку больше. 

Мы так же можем создавать и обычные перменные внутри класса, однако в какой бы функции мы не создали эту переменную, другие функции о ней ничего не узнают.

.. code-block:: python

    def grill(self, food  = None):
        a = 13   # a available only in grill method
        self.b = "cat"
        print (food + " has been grilled")    

    def boil(self, food = None):
        # I have no idea what "a" means :(
        # but I know what "self.b" is   :)

Давайте создадим класс, где вкус и цена еды зависит от уровня повара а так же от возраста еды. А так же немного улучшим работу нашего класса.

.. code-block:: python

    class Cook():

        def __init__(self, cookName = None, cookAge = None, cookLevel = 0):
            # here we initialize the whole class for a specific object

            #cook personal data
            self.name = cookName
            self.age = cookAge
            self.level = cookLevel

            #we don't know food parameters, but we are going to calculate them
            self.food = None
            self.foodAge = None
            self.foodTaste = 0
            self.foodPrice = 0
            self.foodTasteDescription = ""

        def takeFood(self, food = None, foodAge = 1):

            #Reads food info and saves that info to class variables

            if food == None:
                print ("ERROR: I didn't get any food")
                
            self.food = food
            self.foodAge = foodAge

        def calculateFoodValue(self):

            #Calculates food taste and price

            self.foodTaste = self.level - self.foodAge

            if self.foodTaste > 70:
                self.foodPrice = "100$"
                self.foodTasteDescription = "Luxury"

            elif self.foodTaste < 70 and self.foodTaste > 40:
                self.foodPrice = "70$"
                self.foodTasteDescription = "Delicious"

            else:
                self.foodPrice = "30$"
                self.foodTasteDescription = "Regular"

        def serveFood(self):

            #final method

            self.calculateFoodValue()
            print (self.foodTasteDescription + " " + self.food + ", sir! The price is " + self.foodPrice)

        def fry(self):
            print (self.food + " has been fried")
            self.serveFood()

        def boil(self):
            print (self.food + " has been boiled")
            self.serveFood()

        def grill(self):
            print (self.food + " has been grilled")
            self.serveFood()


    cook_1 = Cook(cookName = "Bob", cookAge = "45", cookLevel = 80) #create class object
    cook_1.takeFood(food = "chiken", foodAge = 20) #execute class method
    cook_1.grill() #execute another class method

    """
    prints:
        chiken has been grilled
        Delicious chiken, sir! The price is 70$
    """

    cook_1 = Cook(cookName = "Bill", cookAge = "25", cookLevel = 40) #create class object
    cook_1.takeFood(food = "fish", foodAge = 8) #execute class method
    cook_1.boil() #execute another class method

    """
    prints:
        fish has been boiled
        Regular fish, sir! The price is 30$
    """

Терминология
------------

| **Класс** - структура данных, в которую заключены методы и аттрибуты.
| **Аттрибуты класса** - фактически, переменные, которые видны только объектам класса и могут быть использованы в любом методе класса.
| **Методы класса** - функции внутри класса. Доступны друг другу внутри класса а так же через объекты класса
| **Объект** - (или экземпляр) переменная во внешнем коде, которая является представителем этого класса и позволяет через себя получать доступ к аттрибутам и методам класса
| **Наследование** - Возможность класса унаследовать весь функционал и аттрибуты другого класса



Наследование
------------

Наследование является чуть-ли не самой главной особенностью классов. Когда программисты только придумывали классы как новую структуру данных, они явно брали пример с природы и человека, заложив классам возможность эволюционировать.

Как всегда, простой пример.  У нас есть класс простейшего организма -  у него есть основные для любого живого организма функции - есть, передвигаться в пространстве, защищать себя. Со времененм оно превращается в новый вид, в котором присутствуют все функции простейшего организма плюс новые функции. И так далее, у очередного потомка появляются лапки, хвост, затем больший размер тела, глаза, шипы на коже, зубы, при этом сохраняя функционал своих предков.  Это пример того, как классы могут передавать свои функции и аргументы в другие классы.

А теперь практический пример

.. code-block:: python

    class A(object):

        def __init__ (self):

            self.attr_a = 13
            self.attr_b = "Dog"
            self.attr_c = [1,2,3]

        def method_a(self):
            print "method_a has been run"

    class B(A):

        def __init__(self):

            self.attr_1 = 77
            self.attr_2 = ["a", "b", "c"]

            super(B, self).__init__()

        def method_1(self):
            print "method_1 has been run"
        


    x = B()
    x.method_1() # "method_1 has been run"
    x.method_a() # "method_a has been run"
    print x.attr_c  # ["a", "b", "c"]

В данном примере класс B унаследовал все функции класса A. Для наследования мы всегда должны указывать класс, который наследуем, в аргументых класса.

Как только мы создали объект класса B - мы автоматически получили весь функционал класса B и класса A, однако таким образом мы не получили бы доступ ко всем аттрибутам которые мы объявили в классе A, т.е. для B такие аттрибуты как attr_a, attr_b и attr_c остались бы невидимыми. Чтобы это исправить - мы так же добавили функцию super(B, self).__init__().

Данная функция в классе B создает все переменные, которые мы создали в классе A в функции __init__.  Произошло чтение атрибутов класса А, как только я вставил функцию **super**. Причем важно понимать что если я вставил бы функцию super вначале __init__, то скорее всего мои переменные в классе B могли бы переписать значения переменных класса А, если бы те оказались с такими же именами. Это выбор программиста - вставить функцию super  - в конце __init__ или вначале. Далее небольшой пример с использованием super.

.. code-block:: python

    class A(object):

        def __init__ (self, a = "1000"):

            self.attr_a = a
            self.attr_b = "Dog"
            self.attr_c = [1,2,3]

    class B(A):

        def __init__(self):

            self.attr_1 = 77
            self.attr_2 = ["a", "b", "c"]

            super(B, self).__init__(a = "bobo") # initialize class A attributes with our custom "a" value

            """
            super(B, self).__init__(a = "bobo") can be replaced with 

            self.attr_a = a
            self.attr_b = "bobo"
            self.attr_c = [1,2,3]

            and it will be the same
            """