Введение в программирование в Autodesk Maya | W01
=================================================

Основные тезисы
---------------

* Программирование, в отличие от анимации и моделирования, не требует долгой практики. Достаточно понять один раз, что делает та или иная команда и как работает определенная технология, чтобы начать ею пользоваться.
* Программисты - это один из самых ценных ресурсов компаний. Стоит программисту создать средний или сложный проект, который решает важные задачи компании, уровень зависимости компании от этого программиста многократно увеличивается. 
* Формула успеха в изучении программирования это самостоятельный поиск информации для решения определенных задач. Когда программист читает самостоятельно техническую документацию или ищет в интернете решение конкретной проблемы - вся эта информация откладывается в голове качественно и надолго. Помимо найденного ответа программист получает много дополнительной информации, что впоследствии и составляет его знания о программировании. Когда программист просит кого-то дать готовое решение, он разменивает ценный личный опыт на чужой рецепт, который забудется на следующий день. Можно сравнить готовое решение с тем как аниматор просит другого аниматора сделать за него какую-то работу - в итоге работа сделана а аниматор не получил никакого опыта. 
* Не существует программиста который знает все. Обычно вначале изучают принципы программирования и уже затем человек обнаруживает интерес к какой то конкретной области(создание интерфейсов, серверное программирование, программирование игр и т.д.). Технологии постоянно совершенствуются, как и языки программирования. Изучение чего-то нового - это постоянный процесс. Так же невозможно помнить все команды MEL, Python или любого другого языка программирования - достаточно научиться использовать эти команды, и запомнить сайты где можно найти нужную документацию.
* Изучение программирования происходит поэтапно. Можно представить знания в виде слоев - где самый нижний слой - это самый важный слой - знание основных принципов программирования, опора, на которой держатся уже другие слои. Первый слой даже не относится к какому то конкретному языку программирования.
* Написание новой программы - это 60% поиска информации в интернете и планирования программы на листе бумаги. Остальные 40% - это написание самого кода.
* Задача любой программы - решение проблемы. Чтобы быть успешным программистом - надо понимать предметную область и ее проблемы. Чем четче человек понимает - какую задачу он решает в данный момент, тем проще спланировать программу.

Maya
----

* Программирование в Maya имеет много разных направлений. Задачи могут быть как простыми, которые имеют решение в виде скрипта MEL или Python и пишутся за 20 минут (например сделать выделенный объект прозрачным для лучшего обзора сцены), так и очень сложными, на которые тратятся месяцы, а иногда и годы.
* Большинство задач сводятся к одному принципу  - получение данных сцены Maya и их последующая обработка (модификация, экспорт, выдача статистики и т.д.). 
* В отличие от других языков программирования, MEL это язык команд - т.е. он дает минимум возможностей для создания сложных алгоритмов, однако является превосходным средством для быстрого написания скриптов низкой и средней сложности. Вопреки всяким домыслам, Python не вытеснил MEL, который все еще является популярным среди крупных студий. 
* В Maya не существует разделения на MEL команды и Python команды. Есть понятие команды Maya, которая изначально написана на C++ и существует внутри Maya. MEL и Python это две разные обертки для вызова одних и тех же команд.
* В Майа существует нодовая система, принцип которой очень важно понимать. Любая нода - это коробка со скрытым содержимым, которая отвечает за определенное действие. Например нода mesh отрисовывает полигональный объект во вьюпорте, однако без ноды transform мы не сможем перемещать ноду mesh по сцене.  Мы можем соединять ноды между собой, чтобы получить более сложный эффект. У каждой ноды есть атрибуты (входящие и исходящие). Фактически вся работа Майа - это передача данных из одних нод в другие, а так-же анимация атрибутов нод. 

Практические заметки
--------------------

* Чтобы не потерять скрипт из Script Editor в результате аварийного завершения работы Maya - рекомендуется пользоваться внешними редакторами. В качестве редактора для программирования можно использовать один из трех самых популярных в мире редакторов: https://www.sublimetext.com/, https://atom.io/ или https://code.visualstudio.com/.
* Форумы, на которых можно найти ответы на многие вопросы а так-же задать свои собственные вопросы - https://stackoverflow.com/questions/tagged/mel, https://tech-artists.org/latest
* Maya имеет очень удобную документацию. Любую MEL команду можно посмотреть в http://help.autodesk.com/view/MAYAUL/2018/ENU/?guid=__Commands_index_html
* В самой Maya для написания скриптов используют Script Editor. Верхняя часть этого редактора - это поле, в котором отображаются все MEL команды, которые соответствуют всем действиям пользователя в Maya. Это очень удобно когда надо вспомнить какую-то команду.
* Не все команды, которые отображаются в верхней части Script Editor, имеют описание в технической документации. 


MEL
===

MEL команда очень проста для понимания. Если вы работали с терминалом Linux / MacOS или командной строкой Windows, синтаксис вам будет знаком и понятен.  Сначала идет сама команда, затем атрибуты, и далее имя объекта, для которого нужно эту MEL команду выполнить. Завершается MEL команда точкой с запятой.

.. code-block:: cpp

    Команда -атрибуты имяOбъекта;

    move -relative 2 0 0 pSphere1;

При выполнении команды MEL в Script Editor - команда автоматически удаляется из редактора. Чтобы команда оставалась на месте - необходимо ее выделить (как обычный текст), причем будет выполнена именно выделенная команда - остальной код останется нетронутым. Самый удобный способ запустить MEL команду - это выделить нужный участок кода (или весь код Ctrl+A), и на цифровой клавиатуре нажать Enter.

Скрипт, написанный в Script Editor - можно выделить и средней кнопкой мышки перенести на shelf.  Так же можно создать marking menu с собственными скриптами (Windows -> Settings/Preferences  -> Marking Menu Editor). 

Переменные
----------

Для хранения информации используются переменные. В MEL они начинаются со знака доллара и далее следует название (абсолютно любое). Например:

.. code-block:: cpp

    string $myName = “Roman”;
    int $myAge = 30;
    float $PI = 3.14;
    $someNumber  = 13;

В MEL программист должен указывать тип данных, с которыми он работает. Это позволяет Maya правильно понимать как работать с нашим кодом. MEL так же позволяет объявлять переменные без типа (Майа может автоматически распознать тип данных в переменной), однако это считается плохим подходом в языке MEL, поскольку может привести к непредвиденным ошибкам и добавит сложности в изучении этого языка. 

В MEL существуют следующие типы данных: 

* int (целочисленные, например  2, 44, 23)
* float (с плавающей точкой, например 2.34, 77.5)
* string (текст, например “hello”, “mel is fun”)
* vector (вектор, например <<2 ,5, 0>>)
* matrix (матрицы, например <<1,2,3; 4,5,7; 7,8,9>>)

Рекомендуется давать интуитивно понятные названия переменным, так как это очень сильно упрощает чтение кода. Когда вы напишите сложный скрипт, и вернетесь к нему через месяц чтобы продолжить его улучшать - вы прочувствуете на сколько правильное наименование переменных важно и как это облегчает жизнь. 

Так-же мы можем назначить одной переменной значение другой переменной, однако тип данных у них должен совпадать.

.. code-block:: cpp

    string $myName = “Roman”;
    string $BBB = $myName; // $BBB теперь “Roman”


Некоторые команды MEL возвращают определенный результат (например проверка существования объекта в сцене) и чтобы сохранить этот результат в переменную, достаточно этой переменной присвоить саму команду, заключенную в одинарных обратных кавычках (` - под знаком ~), например`:

.. code-block:: cpp

    //Проверяет существует ли объект в сцене. Если да - возвращает 1, иначе 0
    //Результат команды objExists (1 или 0) мы сохраним в переменную $inScene
    int $inScene = `objExists pSphere1`; 

Для того, чтобы проверить, какое значение в переменной - мы можем это значение вывести в верхней части Script Editor. Для этого используется команда print

.. code-block:: cpp

    //Напечатает: 1
    print($inScene); 


Комментарии в коде
------------------

Любой код нужно комментировать, чтобы в дальнейшем можно было легко вспомнить, что там написано. В MEL любая строка, начинающаяся с // считается комментарием и не обрабатывается Maya. Для превращения целого блока текста в комментарий - достаточно поставить перед ним /* и после него */. Многие языки программирования имеют проблемы с восприятием кириллицы, поэтому писать комментарии нужно на английском. 

.. code-block:: cpp

    //Comments one line
	
    /*
    All text
    here is commented
    */


Массивы
-------

Переменные могут хранить не только одно значение, но так же и целый список значений. Однако все эти значения должны быть одного типа. Такая переменная зовется массивом, и пишется так:

.. code-block:: cpp

    string $name[2] = {"Roman","Volodin"};
    print $name[1]; // напечатает “Volodin”

Следует помнить, что нумерация элементов массивов начинается с НУЛЯ.  Печать $name[0] выдаст "Roman".

Другие способы объявления массивов:

.. code-block:: cpp

    $array1 = {1, 2, 3}; // Maya сама распознает тип данных
    float $array2[] = {12.3, 15.7}; //Можно не указывать явное количество элементов

Чтобы очистить массив, используется команда clear

.. code-block:: cpp

    clear($array1);

Условия
-------

Проверка определенных условий в программе является самым главным принципом программирования. Примерно условие на любом языке программирования можно описать так:  

.. code-block:: cpp

    Команда условия (само условие)
    {
        Если условие выполнилось - выполнить участок кода
    }
    Иначе если (новое условие)
    {
        Выполнить этот код
    }
    Иначе
    {
        Если первые два условия не выполняются, выполнить этот код
    }

Например

.. code-block:: cpp

    int $a = 13;

    if($a == 16)
    {
        print "$a is 16";
    }
    else if($a > 10)
    {
        print "$a is not 16, but bigger than 10";
    }
    else
    {
        print "$a is too small";
    }


Условие, которое мы написали в скобках if($a == 16), сравнивает значение переменной $a с числом 16. Это не единственный тип условий, существуют и другие типы:

.. code-block:: cpp

    if($a == 16)	Если $a равно 16
    if($a != 16)	Если $a не равно 16
    if($a < 16)	    Если $a меньше 16
    if($a > 16)	    Если $a больше 16
    if($a >= 16)	Если $a больше либо равно 16
    if($a <= 16)	Если $a меньше либо равно 16

Мы можем комбинировать различные условия с помощью следующих символов:

.. code-block:: cpp

    //Условие считается выполненным в том случае, если одно из двух сравнений выдало положительный результат
    ||  (ИЛИ)       if($a == 16 || $a > 20) 

    //Условие считается выполненным, если оба сравнения дали положительный результат
    &&	(И)	        if($a == 16 && $a < 20) 

    //Условие выполнено если $a не равно 20
    !	(НЕ)	    if($a != 20) 


**Switch .. case** - вляется альтернативой условия if.  Его удобно применять когда мы должны проверить много условий и если одно из них выполняется - завершить дальнейшую проверку.

.. code-block:: cpp

    int $b = 10;

    switch ($b) {
    case 4:                 //если $b == 4 - вывести текст и завершить условие
        print "$b is 4";
        break;              //оператор завершения 
    case 5:
        print "$b is 5";
        break;
    case 6:
        print "$b is 6";
        break;
    default:
        print "$b is something else";
        break;
    }


**While** является еще одним типом условий. Код внутри блока while будет выполняться, пока не будет выполнено определенное условие. While это опасный оператор, если программа начнет выполнять код внутри while, и условия никогда не будет выполнено - вы столкнетесь с таким явлением как бесконечный цикл, и придется перезагружать Maya без возможности сохранить код или сцену. 

.. code-block:: cpp

    int $a = 1;
    while($a < 10)
    {
        print $;
        $a = $a + 1; // будет добавлять единицу пока $a не будет равно 10
    }

Можно использовать альтернативную конструкцию while

.. code-block:: cpp

    do {
        код
    }
    while (условие)


Циклы
-----

Циклы являются второй очень важной особенностью программирования и служат для работы с массивами. Простыми словами цикл можно описать так: перебрать все элементы массива, и для каждого элемента выполнить код.

Циклы в MEL бывают разными. Самый распространенный вид цикла (который так же имеется и в других языках программирования) выглядит следующим образом

.. code-block:: cpp

    for(инициализация ; условие ; изменение условий)
    {
        код
    }

Данный цикл позволяет выполнить код столько раз, сколько потребуется, пока условие не будет выполнено. 

**Инициализация** это начальное условие цикла. Например переменная $j вначале равна 0.

**Условие** определяет то, когда цикл должен закончиться. Например, когда значение $j достигло 10.

**Изменение** условий определяет то, как $j должна изменяться с каждой итерацией цикла. 

Например 

.. code-block:: cpp

    int $j; //у нас имеется некая переменная, созданная специально для цикла
    $array1 = {"red", "green", "blue"}; // У нас есть массив, хранящий цвета

    //мы обозначили условия цикла. 
    //$j++ увеличивает значение $j на единицу.
    for ($j = 0; $j < 3; $j++){  
        //Мы печатаем элемент массива $array1
        //Как только $j == 3, прекратить работу цикла и продолжить выполнять остальной код
        print ($array1[$j] + "\n");  // \n это символ перехода на новую строку
    }


Более удобный способ перебрать элементы массива - это использовать цикл **for-in**.

.. code-block:: cpp

    $array1 = {"red", "green", "blue"}; // У нас есть массив, хранящий цвета

    for($color in $array1){
        print ($color + "\n");
    }

В данном цикле переменной $color каждый раз присваевается значение очередного элемента массива. Т.е. при первом запуске цикла $color = "red", при втором "green" и т.д. Данный тип цикла является наиболее часто используемым в MEL. 

**break;** - это команда, позволяющая завершить цикл при определенных условиях. В таком случае, имея тысячи элементов в массиве, и найдя нужный нам элемент, команда break избавит Maya от необходимости проверять оставшиеся элементы.. что может занять прилично времени.

.. code-block:: cpp

    $array1 = {"red", "green", "blue"}; // У нас есть массив, хранящий цвета

    for($color in $array1){

        if($color == "green")
        {
            print ($color + "\n");
            break;      //Завершить цикл и продолжить выполнять остальной код
        }
        
    }

**continue;** - это команда, позволяющая перейти к следующей итерации цикла, не выполняя оставшийся код тела цикла. Например:

.. code-block:: cpp

    $array1 = {"red", "green", "blue"}; // У нас есть массив, хранящий цвета

    for($color in $array1){

        if($color == "green")
        {
            print ($color + "\n");
            continue;      //Если $color = "green" - перейти к следующему цвету, минуя сложные вычисления для "green"
        }

        ...
        //Сложные вычисления которые занимают время
        
    }


Разница между = и ==
--------------------

Операторы = и == имеют абсолютно разное назначение. 

Оператор = назначает переменной какое то значение, например $a = 10. Теперь, где бы мы не вызвали $a, мы получим 10.

Оператор == сравнивает значения между левым и правым операндом (операнд - переменные, числа и т.д., т.е. то что обрабатывается). В случае если значения совпадают, возвращается значение True или 1, иначе возвращается False или 0.

Процедуры (функции)
-------------------

Процедуры позволяют взять конкретный участок кода, и занести его в отдельный блок. Таким образом мы делим код на отдельные детали, каждая из которых имеет свое предназначение, и в совокупности они являются программой. 

Процедура начинается с ключевых слов global proc, далее следует название процедуры, круглые скобки () - которые дают Майа понять что это процедура, и фигурные скобки, внутри которых находится код.

.. code-block:: cpp

    global proc MyProc()
    {
        print "test"; // тело функции
    }

Чтобы вызвать процедуру, достаточно написать ее название где-либо в коде. 

.. code-block:: cpp

    //где-то в коде нашей программы 
    MyProc; 

Процедура, как и любая MEL команда, может возвращать результаты. Однако при этом мы должны в объявлении процедуры указать тип возвращаемого значения. Например, если мы производим всякие расчеты, и нам нужно выдать названия геометрического объекта и присвоить его переменной, делается это следующим образом.

.. code-block:: cpp

    global proc string MyObj()
    {
        // тело функции, всякие вычисления
        string $obj = "pSphere1";

        return $obj;
    }

    string $myObject = `MyObj`;

У каждой процедуры могут быть 0 или несколько аргументов. Использование аргументов позволяет использовать процедуры многократно, получая различные результаты.

Например

.. code-block:: cpp

    global proc string MyName(string $firstName, string $secondName)
    {
        string $fullName = ($firstName + " " + $secondName);
        return $fullName;
    }

    print `MyName "Roman" "Volodin"`; // Выдаст "Roman Volodin"


Глобальные переменные 
---------------------

У программы есть разные уровни доступа к переменным. Переменные бывают локальными и глобальными. Если мы создали какую-либо переменную внутри процедуры - она является локальной и видимой только внутри этой процедуры. Попытка обратиться к этой переменной вне процедуры вызовет ошибку. 

Например:

.. code-block:: cpp

    global proc MyProc()
    {
        int $aaa = 15;
    }

    print $aaa; // выдаст ошибку, т.к. $aaa существует внутри MyProc.

Чтобы переменная стала глобальной, нужно поставить ключевое слово global перед объявлением переменной, и далее объявлять ее на всех уровнях доступа, чтобы дать понять что мы имеем дело с глобальной переменной.

.. code-block:: cpp

    global proc MyProc()
    {
        global int $bbb;
        print $bbb;
    }

    global proc AnotherProc()
    {   
        global int $bbb;
        print $bbb;
    }

    global int $bbb = 20;

    MyProc;
    AnotherProc;

